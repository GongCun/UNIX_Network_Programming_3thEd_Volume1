head	1.9;
access;
symbols;
locks
	gongcun:1.9; strict;
comment	@ * @;


1.9
date	2016.11.01.14.21.16;	author gongcun;	state Exp;
branches;
next	1.8;

1.8
date	2016.11.01.14.15.37;	author gongcun;	state Exp;
branches;
next	1.7;

1.7
date	2016.05.22.01.21.47;	author gongcun;	state Exp;
branches;
next	1.6;

1.6
date	2016.05.21.15.11.52;	author gongcun;	state Exp;
branches;
next	1.5;

1.5
date	2016.05.21.11.58.26;	author gongcun;	state Exp;
branches;
next	1.4;

1.4
date	2016.05.19.12.34.08;	author gongcun;	state Exp;
branches;
next	1.3;

1.3
date	2016.05.19.05.25.33;	author gongcun;	state Exp;
branches;
next	1.2;

1.2
date	2016.05.19.05.11.59;	author gongcun;	state Exp;
branches;
next	1.1;

1.1
date	2016.05.19.05.00.35;	author gongcun;	state Exp;
branches;
next	;


desc
@@


1.9
log
@*** empty log message ***
@
text
@#include "unp.h"
#include <pcap.h>
#ifdef AIX
#include <net/bpf.h>
#include <netinet/if_ether.h>
#else
#include <net/ethernet.h>
#endif

#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <libgen.h>
#include <time.h>

#define SNAPLEN 1518
#define PAKNUM -1		/* infinity */
void handler(u_char *, const struct pcap_pkthdr *, const u_char *);
void handler_udp(const struct pcap_pkthdr *header, const u_char * packet);
void dlt_print_payload(const u_char *, int);

static int linktype;
static int fd;

int 
main(int argc, char *argv[])
{				/* dlt_sniff dev expression */
	char *strdev, filterexp[MAXLINE];
	if (argc != 3)
		err_quit("Usage: %s dev 'filter_exp'", basename(argv[0]));

	strdev = argv[1];
	strncpy(filterexp, argv[2], sizeof(filterexp));
#ifdef _DEBUG
	printf("filterexp = %s\n", filterexp);
#endif

	/* open file to record the payload */
	if ((fd = open("./record.pcap", O_RDWR | O_CREAT | O_TRUNC, 0644)) < 0)
		err_sys("open file error");

	bpf_u_int32 mask;
	bpf_u_int32 net;
	char errbuf[PCAP_ERRBUF_SIZE];

	if (pcap_lookupnet(strdev, &net, &mask, errbuf) < 0) {
		fprintf(stderr, "Can't get netmask for device %s: %s\n", strdev, errbuf);
		mask = 0;
		net = 0;
	}
	char str[64];
	if (inet_ntop(AF_INET, &net, str, sizeof(str)) == NULL)
		err_sys("inet_ntop error");
	printf("%s net: %s\n", strdev, str);
	if (inet_ntop(AF_INET, &mask, str, sizeof(str)) == NULL)
		err_sys("inet_ntop error");
	printf("%s mask: %s\n", strdev, str);

	pcap_t *ppt;
	bzero(errbuf, sizeof(errbuf));
	if ((ppt = pcap_open_live(strdev, SNAPLEN, 1, 1000, errbuf)) == NULL)
		err_quit("pcap_open_live error: %s", errbuf);
	if (strlen(errbuf) != 0)
		fprintf(stderr, "Warning: %s", errbuf);

	if ((linktype = pcap_datalink(ppt)) < 0)
		err_quit("pcap_datalink error: %s", pcap_geterr(ppt));
	if (linktype == 0)	/* DLT_NULL: 0 */
		printf("loopback\n");
	else if (linktype == 1)	/* DLT_EN10MB: 1 */
		printf("ethernet\n");
	else
		err_quit("unsupported datalink (%d)", linktype);

	struct bpf_program bpCode;
	if (pcap_compile(ppt, &bpCode, filterexp, 0, mask) < 0)
		err_quit("pcap_compile error: %s", pcap_geterr(ppt));
	if (pcap_setfilter(ppt, &bpCode) < 0)
		err_quit("pcap_setfilter error: %s", pcap_geterr(ppt));

	/* now setup callback function */
	if (pcap_loop(ppt, PAKNUM, &handler, NULL) == -1)
		err_quit("pcap_loop error: %s", pcap_geterr(ppt));

	/* cleanup */
	pcap_freecode(&bpCode);
	pcap_close(ppt);
	close(fd);

	printf("\nCapture complete.\n");

	return 0;
}


void 
handler(u_char * args, const struct pcap_pkthdr *header, const u_char * packet)
{
	static int count = 0;
	printf("\nPacket number %d:\n", count++);

	/* get daytime */
	char tmbuf[64], buf[64];
	struct tm *tm = localtime(&(header->ts.tv_sec));
	strftime(tmbuf, sizeof(tmbuf), "%Y-%m-%d %H:%M:%S", tm);
	snprintf(buf, sizeof(buf), "%s.%06d", tmbuf, header->ts.tv_usec);
	printf("%s\n", buf);

	/* const struct ether_header *peth; */
	const struct ip *pip;
	const struct tcphdr *ptcp;
	const u_char *payload;

	/* peth = (struct ether_header *)packet; */
	int size_eth = 14;
	if (linktype == 0)
		size_eth = 4;
	int size_ip;
	pip = (struct ip *)(packet + size_eth);
	size_ip = pip->ip_hl * 4;
	if (size_ip < 20) {
		fprintf(stderr, "   * Invalid IP header length: %u bytes\n", size_ip);
		return;
	}
	char strsrc[64], strdst[64];
	if (inet_ntop(AF_INET, &pip->ip_src, strsrc, sizeof(strsrc)) == NULL)
		err_sys("inet_ntop error");
	if (inet_ntop(AF_INET, &pip->ip_dst, strdst, sizeof(strdst)) == NULL)
		err_sys("inet_ntop error");
	printf("From %s to %s\n", strsrc, strdst);

	if (pip->ip_p != IPPROTO_TCP && pip->ip_p != IPPROTO_UDP) {
		fprintf(stderr, "unsupported protocol: %d\n", pip->ip_p);
		return;
	}
	if (pip->ip_p == IPPROTO_UDP) {
		handler_udp(header, packet);
		return;
	}
	/* tcp */
	ptcp = (struct tcphdr *)(packet + size_eth + size_ip);
	int size_tcp = ptcp->th_off * 4;
	if (size_tcp < 20) {
		fprintf(stderr, "   * Invalid TCP header length: %u bytes\n", size_tcp);
		return;
	}
	printf("Src port: %d, Dst port %d\n", ntohs(ptcp->th_sport), ntohs(ptcp->th_dport));
	printf("Seq: %u, Ack %u\n", ntohl(ptcp->th_seq), ntohl(ptcp->th_ack));

	payload = (u_char *) (packet + size_eth + size_ip + size_tcp);
	int size_payload;
#ifdef _DEBUG
	printf("%d\n", header->caplen - size_eth - size_ip - size_tcp);
	printf("%d\n", ntohs(pip->ip_len) - size_ip - size_tcp);
#endif
	size_payload = header->caplen - size_eth - size_ip - size_tcp;

	if (size_payload > 0) {
		printf("Payload (%d bytes).\n", size_payload);
		dlt_print_payload(payload, size_payload);
	}
	return;
}

void 
dlt_print_payload(const u_char * payload, int len)
{
	if (write(fd, payload, len) != len)
		perror("write error");
}

void 
handler_udp(const struct pcap_pkthdr *header, const u_char * packet)
{
	const struct ip *pip;
	const struct udphdr *pudp;
	u_char *payload;
	int size_eth, size_ip, size_udp = sizeof(struct udphdr), size_payload;

	size_eth = (linktype == 0) ? 4 : 14;
	pip = (struct ip *)(packet + size_eth);
	if ((size_ip = pip->ip_hl * 4) < 20) {
		fprintf(stderr, "   * Invalid IP header length: %u bytes\n", size_ip);
		return;
	}
	pudp = (struct udphdr *)(packet + size_eth + size_ip);
	if (header->caplen - size_eth - size_ip < size_udp) {
		fprintf(stderr, "   * Invalid UDP header length: %u bytes\n", header->caplen - size_eth - size_ip);
		return;
	}
	printf("Src port: %d, Dst port %d\n", ntohs(pudp->uh_sport), ntohs(pudp->uh_dport));
	printf("data length = %d\n", ntohs(pudp->uh_ulen));
	printf("check sum = 0x%x\n", pudp->uh_sum);

	payload = (u_char *) (packet + size_eth + size_ip + size_udp);
	size_payload = header->caplen - size_eth - size_ip - size_udp;
	if (size_payload > 0) {
		printf("payload (%d bytes).\n", size_payload);
		dlt_print_payload(payload, size_payload);
	}
	return;
}
@


1.8
log
@*** empty log message ***
@
text
@d4 2
a5 2
  #include <net/bpf.h>
  #include <netinet/if_ether.h>
d7 1
a7 1
  #include <net/ethernet.h>
d17 1
a17 1
#define PAKNUM -1 /* infinity */ 
d19 1
a19 1
void handler_udp(const struct pcap_pkthdr *header, const u_char *packet);
d25 6
a30 5
int main(int argc, char *argv[]) /* dlt_sniff dev expression */
{
    char *strdev, filterexp[MAXLINE];
    if (argc != 3)
        err_quit("Usage: %s dev 'filter_exp'", basename(argv[0]));
d32 2
a33 2
    strdev = argv[1];
    strncpy(filterexp, argv[2], sizeof(filterexp));
d35 1
a35 1
    printf("filterexp = %s\n", filterexp);
d39 1
a39 1
	if ((fd = open("./record.pcap", O_RDWR|O_CREAT|O_TRUNC, 0644)) < 0)
d42 27
a68 28
    bpf_u_int32 mask;
    bpf_u_int32 net;
    char errbuf[PCAP_ERRBUF_SIZE];

    if(pcap_lookupnet(strdev, &net, &mask, errbuf) < 0) {
        fprintf(stderr, "Can't get netmask for device %s: %s\n", strdev, errbuf);
        mask = 0;
        net = 0;
    }

    char str[64];
    if (inet_ntop(AF_INET, &net, str, sizeof(str)) == NULL)
        err_sys("inet_ntop error");
    printf("%s net: %s\n", strdev, str);
    if (inet_ntop(AF_INET, &mask, str, sizeof(str)) == NULL)
        err_sys("inet_ntop error");
    printf("%s mask: %s\n", strdev, str);

    pcap_t *ppt;
    bzero(errbuf, sizeof(errbuf));
    if ((ppt = pcap_open_live(strdev, SNAPLEN, 1, 1000, errbuf)) == NULL)
        err_quit("pcap_open_live error: %s", errbuf);
    if (strlen(errbuf) != 0)
        fprintf(stderr, "Warning: %s", errbuf);

    if ((linktype = pcap_datalink(ppt)) < 0)
        err_quit("pcap_datalink error: %s", pcap_geterr(ppt));
    if (linktype == 0) /* DLT_NULL: 0 */
d70 1
a70 1
	else if (linktype == 1) /* DLT_EN10MB: 1 */
d73 1
a73 1
        err_quit("unsupported datalink (%d)", linktype);
d75 13
a87 13
    struct bpf_program bpCode;
    if (pcap_compile(ppt, &bpCode, filterexp, 0, mask) < 0)
        err_quit("pcap_compile error: %s", pcap_geterr(ppt));
    if (pcap_setfilter(ppt, &bpCode) < 0)
        err_quit("pcap_setfilter error: %s", pcap_geterr(ppt));
    
    /* now setup callback function */
    if (pcap_loop(ppt, PAKNUM, &handler, NULL) == -1)
        err_quit("pcap_loop error: %s", pcap_geterr(ppt));

    /* cleanup */
    pcap_freecode(&bpCode);
    pcap_close(ppt);
d90 1
a90 1
    printf("\nCapture complete.\n");
d92 1
a92 1
    return 0;
d96 2
a97 1
void handler(u_char *args, const struct pcap_pkthdr *header, const u_char *packet)
d99 2
a100 2
    static int count = 0;
    printf("\nPacket number %d:\n", count++);
d109 14
a122 14
    /* const struct ether_header *peth; */
    const struct ip *pip;
    const struct tcphdr *ptcp;
    const u_char *payload;

    /* peth = (struct ether_header *)packet; */
    int size_eth = 14;
    if (linktype == 0)
        size_eth = 4;
    int size_ip;
    pip = (struct ip *)(packet + size_eth);
    size_ip = pip->ip_hl * 4;
    if (size_ip < 20) {
        fprintf(stderr, "   * Invalid IP header length: %u bytes\n", size_ip);
d125 6
d132 8
a139 16
    char strsrc[64], strdst[64];
    if (inet_ntop(AF_INET, &pip->ip_src, strsrc, sizeof(strsrc)) == NULL)
        err_sys("inet_ntop error");
    if (inet_ntop(AF_INET, &pip->ip_dst, strdst, sizeof(strdst)) == NULL)
        err_sys("inet_ntop error");
    printf("From %s to %s\n", strsrc, strdst);

    if (pip->ip_p != IPPROTO_TCP && pip->ip_p != IPPROTO_UDP) {
        fprintf(stderr, "unsupported protocol: %d\n", pip->ip_p);
        return;
    }
    if (pip->ip_p == IPPROTO_UDP) {
        handler_udp(header, packet);
        return;
    }

d141 2
a142 2
    ptcp = (struct tcphdr *)(packet + size_eth + size_ip);
	int size_tcp = ptcp -> th_off * 4;
d144 1
a144 1
        fprintf(stderr, "   * Invalid TCP header length: %u bytes\n", size_tcp);
d150 1
a150 1
	payload = (u_char *)(packet + size_eth + size_ip + size_tcp);
d153 1
a153 1
	printf("%d\n", header->caplen - size_eth - size_ip -size_tcp);
d156 1
a156 1
	size_payload = header->caplen - size_eth - size_ip -size_tcp;
d162 1
a162 2

    return;
d165 2
a166 1
void dlt_print_payload(const u_char *payload, int len)
d168 2
a169 2
    if (write(fd, payload, len) != len)
        perror("write error");
d172 2
a173 1
void handler_udp(const struct pcap_pkthdr *header, const u_char *packet)
d175 27
a201 28
    const struct ip *pip;
    const struct udphdr *pudp;
    u_char *payload;
    int size_eth, size_ip, size_udp = sizeof(struct udphdr), size_payload;

    size_eth = (linktype == 0) ? 4 : 14;
    pip = (struct ip *)(packet + size_eth);
    if ((size_ip = pip->ip_hl * 4) < 20) {
        fprintf(stderr, "   * Invalid IP header length: %u bytes\n", size_ip);
		return;
    }

    pudp = (struct udphdr *)(packet + size_eth + size_ip);
    if (header->caplen - size_eth - size_ip < size_udp) {
        fprintf(stderr, "   * Invalid UDP header length: %u bytes\n", header->caplen - size_eth - size_ip);
        return;
    }
    printf("Src port: %d, Dst port %d\n", ntohs(pudp->uh_sport), ntohs(pudp->uh_dport));
    printf("data length = %d\n", ntohs(pudp->uh_ulen));
    printf("check sum = 0x%x\n", pudp->uh_sum);

    payload = (u_char *)(packet + size_eth + size_ip + size_udp);
    size_payload = header->caplen - size_eth - size_ip - size_udp;
    if (size_payload > 0) {
        printf("payload (%d bytes).\n", size_payload);
        dlt_print_payload(payload, size_payload);
    }
    return;
a202 1

@


1.7
log
@*** empty log message ***
@
text
@d149 1
@


1.6
log
@*** empty log message ***
@
text
@d193 1
a193 1
    printf("check sum == 0x%x\n", pudp->uh_sum);
a203 2
    
    
@


1.5
log
@*** empty log message ***
@
text
@d12 1
d19 1
d108 1
a108 1
    const struct ether_header *peth;
d113 1
a113 1
    peth = (struct ether_header *)packet;
d132 1
a132 1
    if (pip->ip_p != IPPROTO_TCP) {
d136 4
d171 35
@


1.4
log
@*** empty log message ***
@
text
@d23 1
a23 1
int main(int argc, char *argv[]) /* dlt_sniff dev ip port */
d26 2
a27 2
    if (argc != 4)
        err_quit("Usage: %s dev ip port", basename(argv[0]));
d30 4
a33 2
    snprintf(filterexp, sizeof(filterexp), "src host %s and tcp and port %d",
            argv[2], atoi(argv[3]));
d130 5
@


1.3
log
@*** empty log message ***
@
text
@d16 1
a16 1
#define PAKNUM 10
d21 1
d30 1
a30 1
    snprintf(filterexp, sizeof(filterexp), "host %s and tcp and port %d",
d33 4
d84 1
d146 1
a146 1
		printf("Payload (%d bytes):\n", size_payload);
d155 1
a155 1
    if (write(1, payload, len) != len)
@


1.2
log
@*** empty log message ***
@
text
@a2 1
#include <net/bpf.h>
d4 2
a5 1
	#include <netinet/if_ether.h>
d7 1
a7 1
	#include <net/ethernet.h>
d9 1
d140 1
a140 1
		printf("  Payload (%d bytes):\n", size_payload);
@


1.1
log
@Initial revision
@
text
@d1 8
a8 2
#include "udpcksum-ex.h"
#include <net/ethernet.h>
d12 1
d17 1
d19 1
a19 1
int linktype;
d58 5
a62 1
    if (linktype != DLT_NULL && linktype != DLT_EN10MB)
d90 7
d99 1
a99 1
    const struct tcphdr *tcp;
d103 2
a104 2
    int size_eth = 14; /* DLT_EN10MB */
    if (linktype == DLT_NULL)
d109 1
a109 1
    if (size_ip < 20)
d111 2
d121 22
d145 6
@
